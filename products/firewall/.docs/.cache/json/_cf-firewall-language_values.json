{"data":{"mdx":{"id":"1346c815-406e-5ff8-a316-9652b97a7acb","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"pcx-content-type\": \"reference\",\n  \"order\": 630\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"values\"\n  }, \"Values\"), mdx(\"p\", null, \"When an HTTP request reaches Cloudflare\\u2019s edge, Cloudflare creates a table of field\\u2013value pairs against which to match expressions. This table exists for as long as the current request is being processed.\"), mdx(\"p\", null, \"The values that populate Firewall Rules lookup tables are drawn from a variety of sources:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Primitive properties\"), \" are obtained directly from the request (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"http.request.uri.path\"), \", for example).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Derived values\"), \" are the product of a transformation, composition, or basic operation. For example, the transformation \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"lower(http.request.uri.patch)\"), \" converts the value of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"http.request.uri.path\"), \" to lowercase.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Computed values\"), \" are the product of a lookup, computation, or other intelligence. For example, Cloudflare uses a machine learning process to dynamically calculate threat scores, represented by the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cf.threat_score\"), \" field.\")), mdx(\"p\", null, \"When working with values in Firewall Rules expressions, keep in mind the notes outlined below for escape characters, case sensitivity, and boolean values.\"), mdx(\"h2\", {\n    \"id\": \"escape-characters-in-values\"\n  }, \"Escape characters in values\"), mdx(\"p\", null, \"You must manually escape the backslash (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\\"), \") and double quote (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"\"), \") characters with a backslash when using them as part of a literal value in an expression.\"), mdx(\"p\", null, \"Note in this example that the first and last \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"\"), \" characters in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"token-type=\\\\\\\"JWT\\\\\\\"\\\"\"), \" are not part of the literal value, so they do not need escaping:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"(http.request.uri.query contains \\\"token-type=\\\\\\\"JWT\\\\\\\"\\\")\\n\")), mdx(\"h2\", {\n    \"id\": \"case-sensitivity-and-regular-expressions-in-values\"\n  }, \"Case sensitivity and regular expressions in values\"), mdx(\"p\", null, \"Since the evaluation of expressions using string values is case-sensitive, consider writing more than one simple expression to capture variants.\"), mdx(\"p\", null, \"Cloudflare Business and Enterprise customer plans have access to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"matches\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/cf-firewall-language/operators/#comparison-operators\"\n  }, \"comparison operator\"), \" which supports regular expressions, so that you can capture multiple variants of a value with a single expression.\"), mdx(\"h2\", {\n    \"id\": \"boolean-values\"\n  }, \"Boolean values\"), mdx(\"p\", null, \"Simple expressions using boolean fields do not require operator notations or values. You only need to insert the field on its own, as shown in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ssl\"), \" example below.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"ssl\\n\")), mdx(\"p\", null, \"This simple expression matches requests where the value of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ssl\"), \" field is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \".\"), mdx(\"p\", null, \"To match requests where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ssl\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \", use the boolean \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"not\"), \" operator :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"not ssl\\n\")), mdx(\"h2\", {\n    \"id\": \"arrays\"\n  }, \"Arrays\"), mdx(\"p\", null, \"The Cloudflare Firewall Rules language includes \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/cf-firewall-language/fields\"\n  }, \"fields\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array\"), \" type and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/cf-firewall-language/functions\"\n  }, \"functions\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array\"), \" arguments and return values.\"), mdx(\"p\", null, \"You can access individual array elements using an index (a non-negative value) between square brackets (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]\"), \"). Array indexes start at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" (zero).\"), mdx(\"p\", null, \"Use the special notation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \" when specifying an expression that will be evaluated for each array element (like the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://wikipedia.org/wiki/Map_(higher-order_function)\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"map\"), \" high-order function\"), \"). This special index notation will unpack the array, call the enclosing function for all its elements individually, and return a new array containing all the individual return values.\"), mdx(\"h3\", {\n    \"id\": \"examples\"\n  }, \"Examples\"), mdx(\"p\", null, \"Consider the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http.request.headers.names\"), \" field with type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array<String>\"), \" in the following examples:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Obtain the first element in the array:\", mdx(\"br\", null), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http.request.headers.names[0]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check if the first array element is equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Content-Type\"), \" (case sensitive):\", mdx(\"br\", null), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http.request.headers.names[0] == \\\"Content-Type\\\"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check if any array element is equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Content-Type\"), \" (case sensitive):\", mdx(\"br\", null), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any(http.request.headers.names[*] == \\\"Content-Type\\\")\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Check if any array element is equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Content-Type\"), \", ignoring the case:\", mdx(\"br\", null), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any(lower(http.request.headers.names[*])[*] == \\\"content-type\\\")\")))), mdx(\"p\", null, \"In the last example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lower()\"), \" function includes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \" notation so that the function is evaluated for each array element. This function, used along \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \", returns a new array where each element of the input array is converted to lowercase. Then, the string comparison uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \" to transform the array resulting from applying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lower()\"), \" to each header name into an array of boolean values. Finally, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any()\"), \" evaluates to true if at least one of these array elements is true.\"), mdx(\"h3\", {\n    \"id\": \"final-notes\"\n  }, \"Final notes\"), mdx(\"p\", null, \"It is not possible to define your own arrays. You can only use arrays returned by fields, either directly or modified by functions.\"), mdx(\"p\", null, \"Accessing an out-of-bounds array index produces a \\\"missing value\\\". A missing value has the following behavior:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any comparison \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<expr> <op> <literal>\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<expr>\"), \" evaluates to a missing value will evaluate to false.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Function calls like \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"function(<expr>)\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<expr>\"), \" evaluates to a missing value, will return a missing value in most cases, but the exact behavior can vary per function.\")), mdx(\"p\", null, \"You can only use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \" multiple times in the same expression if applied to the same array. Also, you can only use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \" in the first argument of a function call.\"), mdx(\"p\", null, \"The Firewall Rules language \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/cf-firewall-language/operators\"\n  }, \"operators\"), \" do not directly support arrays or the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \" operator \\u2014 however, they support indexed array elements like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array_value[0]\"), \". For example, you cannot use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[*]\"), \" with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"==\"), \" operator outside the context of an enclosing function call:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"http.request.headers.names[*] == \\\"Content-Type\\\"\"), \" \\u2014 \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Invalid\"), \" expression\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"any(http.request.headers.names[*] == \\\"Content-Type\\\")\"), \" \\u2014 \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Valid\"), \" expression\")), mdx(\"h2\", {\n    \"id\": \"ip-lists\"\n  }, \"IP Lists\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/cf-firewall-rules/rules-lists\"\n  }, \"IP Lists\"), \" allow you to create a group of IP addresses and refer to them collectively, by name, in your firewall rule expressions.\"), mdx(\"p\", null, \"To refer to an IP List in a firewall rule expression, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$<list_name>\"), \" and specify the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"in\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/cf-firewall-language/operators\"\n  }, \"operator\"), \". This example expression filters requests from IP addresses that are in an IP List named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"office_network\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"(ip.src in $office_network)\\n\")), mdx(\"p\", null, \"Note that names for IP Lists can only include lowercase letters, numbers, and the underscore (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_\"), \") character. For guidance on creating and managing lists, refer to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developers.cloudflare.com/firewall/cf-dashboard/rules-lists/manage-lists\"\n  }, \"Use IP Lists: Manage Lists\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"demo":null,"difficulty":null,"summary":null,"tags":null,"title":"","type":null,"updated":null}}},"pageContext":{"id":"1346c815-406e-5ff8-a316-9652b97a7acb","fields":{"slug":"/cf-firewall-language/values"},"frontmatter":{"title":"","type":null,"order":630,"hidden":null,"hideChildren":null,"breadcrumbs":null},"headings":[{"value":"Values","depth":1}],"tableOfContents":{"items":[{"url":"#values","title":"Values","items":[{"url":"#escape-characters-in-values","title":"Escape characters in values"},{"url":"#case-sensitivity-and-regular-expressions-in-values","title":"Case sensitivity and regular expressions in values"},{"url":"#boolean-values","title":"Boolean values"},{"url":"#arrays","title":"Arrays","items":[{"url":"#examples","title":"Examples"},{"url":"#final-notes","title":"Final notes"}]},{"url":"#ip-lists","title":"IP Lists"}]}]},"parent":{"modifiedTime":"2021-12-17","relativePath":"cf-firewall-language/values.md"}}}